


% \paragraph{Reverse maths}
The program of reverse mathematics, first initiated by Friedman in the 70s,
aims at answering questions of the form: ``\emph{what are the minimal axioms necessary to derive the theorem $T$?}''.
To do so, formulas are classified via their logical equivalence classes over the ambient theory $\T$, which has then to be chosen carefully.
Indeed, $\T$ has to be expressive enough for usual mathematical statements to have meaning, while a too strong theory would identify all the provable formulas. Classical reverse mathematics has now identified a well-
established hierarchy of subsystems of second-order arithmetic serving this purpose~\cite{Simpson09}, but the literature in constructive reverse mathematics is much more recent and the situation is more complex: several principles compatible with constructive mathematics lead to logical inconsistencies when added together (\emph{e.g.}, Church’s thesis and the law of excluded-middle).





% \paragraph{Constructive reverse maths}
% \emnote{Choice principles,Brede-Herbelin, intuitionistic logic}
Among the various limitations that classical reverse mathematics present
from a constructive point of view,  they are for instance intrinsically
bound to classify theorems that are compatible with classical logic (which is not the case for all intuitionistic theorems), or unable do distinguish between a statement and its contrapositive.
More recently, Ishihara advocated for a constructive approach to reverse
mathematics to overcome such limitations~\cite{Ishihara06}, but with
purely logical considerations, without paying attention to the computational counterpart of constructive results.
It is only during the last few years that works in that direction were developed, especially around Gödel's completeness theorem for first-order logic~\cite{HerIli22,ForKirWeh21}.
We advocate for a generalization of this approach, which has shown to be very conducive over the past few years~\cite{KirZen25,CohEtAl24,HerKir24,Bauer22}.
% is tailored for that purpose, by tackling first the problem of capturing the
% precise computational counterpart of choice principles.


% \paragraph{Choice principles}
In a recent paper, Brede \& Herbelin put forward a generalized variant of the dependent choice $\GDC_{ABT}$, and its contrapositive bar induction principle $\GBI_{ABT}$, expressed in terms of tree~\cite{BreHer21}.
% named $\GDC_{ABT}$ and $\GBI_{ABT}$.
Different instantiations of the parameters $A$, $B$, $T$, which refer to the objects they apply to, allow to capture
a structured hierarchy of choice principles, ranging from Weak K\"onig's Lemma
(when $A$ is the type $\bN$ of natural numbers and $B$ is the type $\mathbb{B}$ of Booleans)
to the relational variant of the Axiom of Choice
(when $T$ is a filter induced by the considered relation), together with their contrapositive.
Following the recent advances in constructive reverse mathematics, we suggest to consider these principles with a computational point of view, and especially the question:
\begin{center}
 ``\emph{What is the computational content of each of these principles?}''
\end{center}







% \paragraph{Realizability interpretations}
Adressing such a question raises several difficulties.
First and foremost, we need to understand how to relate advanced logical principles with computational features.
To that end, we rely on realizability interpretations, and especially on the recent literature in lines with Krivine approach which unveiled that adding programing instructions to a programing language can lead to interpreting new reasoning principles~\cite{Krivine04,Miquel11,Miquey18a,Geoffroy18,CohFarTat19,Blot22}

Besides, we need to figure out what it means to  capture \emph{exactly} the computational content of a logical principle. We believe that a satisfying answer to that question should address the three following points.
First, is the computational content exhibited enough? It should be the fact that the expected principle is validated not because of some implicit restrictions, but in a setting that is also compatible with further computational extensions.
For instance, the relational variant of the Axiom of Choice is trivially valid in a setting with strong existential (such as Martin-Löf Type Theory or intuitionistic realizability interpretations based on a purely functional language) but this is due to the implicit restrictions that a realizer of $A\to B$ is necesarily a function. This does not survive to extension with effects, allowing for a coin flip is enough to refute it~\cite{CohFarTat19}. In contrast, several works show how Countable Choice can be validated using memoization techniques in presence of effects~\cite{BerBezCoq98,Herbelin12,Miquey18a,CohFarTat19}.

Secondly, how can we know that the computational features we consider are not too much? For instance, it is clear that if memoization techniques allow to validate Countable Choice in presence of classical logic, such settings will also entail \Konig's Lemma and the Fan Theorem. We therefore suggest to look for realizability models providing separation results: \emph{e.g.}, to capture the exact computational content of Countable Choice, one should aim for a model refuting Dependent Choice.

Thirdly, we should aim to offer robust interpretations, \emph{i.e.} to ensure that the validity of the interpretation is only a consequence of the studied computational features (say, memoization) and not peculiar to specificities of the underlying language of realizers (say, some $\lambda$-calculus). To that end, we suggest relying on \emph{evidenced frames}~\cite{CohMiqTat21}, which provide an algebraic representation of realizability models and allow us to express robust statements such as:
\emph{``any computational system providing an implementation of \emph{(a)} will induce an evidenced frame validating \emph{(b)}}''. In particukar, Cohen \emph{et al.} proved that memoization techniques (a) in any of a variety of computational systems would lead to a realizability model of Countable Choice (b), which is a much stronger result than the definition of a specific model of the same axiom in ~\cite{Herbelin12,Miquey18a} based on an ad-hoc variant of the $\lambda$-calculus with some implementation of memoization.








\paragraph{The computational content of the Fan Theorem}


In this paper, we focus on the lowest principles of Brede-Herbelin hierarchy, namely Brouwer's Fan Theorem (\FT). Considering trees as prefix-closed sets of lists of natural numbers, a set $C$ whose complement is a finitely branching tree is said to be \emph{barred} if it contains a finite prefix $\alpha_n$ of any infinite sequence $\alpha\in\bN^\bN$. It is \emph{uniformly barred} if there exists a natural number $n$ such that for any $\alpha\in\bN^\bN$, $\restr\alpha n\in C$.
The Fan Theorem states that if such a set is barred, then it is uniformly barred. This can be understood as the contrapositive of \Konig's Lemma (\KL), which states that a tree is infinite if it contains an infinite path, and both statements have a weak variant (\WFT and \WKL) restricted to binary trees (and thus lists/sequences of booleans). In particular, \KL is known to be strictly stronger than \WKL and to entail \FT.
As explained, constructive reverse mathematics are much more subtle than classical mathematics, which explains that even though a principle such as Brouwer's continuity principle was first stated more than a century ago~\cite{Brouwer1919}, continuity principles and their consequences, in particular $\FT$, are still actively studied in constructive settings~\cite{VanAttenVanDalen2002,VeldmanBrouwer2022,BergerDecomposition2009,FujiwaraExtensionEquivalenceBrouwers2022,FujiwaraChoicePrinciplesCharacterizing2025,BaiEtAl25,CohRah23}.



\paragraph{Contributions of this paper}
In this work, we aim to provide a computational interpretation of the Fan Theorem while following our manifesto: we therefore provide a realizability interpretation satisfying \FT while refuting \WKL.
To do so, we take inspiration from Lubarsky \& Rathjen work~\cite{LubRat13}, where they sketch the definition of such a model based on a mix of a Kripke semantics and realizability: a sequence of reals of increasing Turing degree over the worlds is used as an oracle, and at each world the computable functions are used to define a PCA-based realizability model.
Here, in order to better stress the computational behavior of realizers, in \Cref{s:realizability} we rather consider a $\lambda$-calculus extended with oracles and we use it to to define a realizability interpretation in the spirit of relative realizability~\cite{VanOosten08}. In \Cref{s:FT}, we prove that our system satisfies a continuity property and use it to exhibit a simple $\lambda$-term which realizes \FT. We also show that our model refutes \WKL, thus providing a separation result. Last, we identify in \Cref{s:robust} the computational features of our construction, namely a continuity property, strong existentials and unbounded search, and we provide a robust version of the validity of \FT usong evidenced frames.









\newcommand{\ZFC}{ZFC}
\newcommand{\ZF}{ZF}
\newcommand{\RCAO}{RCA0}
\newcommand{\RCA}{RCA}
\newcommand{\double}{double}
\newcommand{\intt}{int}
% \newcommand{\FT}{FT}
%
%
% Les math\'ematiques usuelles se d\'eroulent dans $\ZFC$. Dans cette pratique des math\'ematiques, l'objectif est de d\'emontrer un maximum de r\'esultats, sans consid\'eration pour les moyens logiques employ\'es (sous r\'eserve que ceux-ci soient coh\'erents). Le cadre de ce rapport, celui des math\'ematiques à rebours, cherche au contraire à \'etudier la force logique de r\'esultats d\'ejà d\'emontr\'es~: quels principes doit-on admettre pour les d\'emontrer ?
%
% Cette question est renouvel\'ee dans le cadre de la logique intuitionniste et des math\'ematiques constructivistes (qui n'acceptent que les proc\'ed\'es d\'emonstratifs explicites), puisque l'on peut \'etudier le caractère constructif des principes en plus de leur force logique. Dans cette \'etude, une famille de formules a un rôle privil\'egi\'e : les principes de choix. Leur forme g\'en\'erale est
% \[\forall x^A, \exists y^B, R(x,y) \implies \exists f^{A\to B}, \forall x^A, R(x,f(x))\]
% Où $R$ est une relation binaire entre $A$ et $B$. Suivant le choix de $A,B$ et des formes que peut prendre $R$, on obtient de nombreux principes de choix. On peut, de plus, \'etudier une variante de ces principes en en prenant la contrapos\'ee~: en logique intuitionniste, ces ``principes de co-choix'' sont plus faibles, souvent strictement.
%
% Dans ce rapport, nous \'etudierons l'un des principes les plus faibles~: le lemme de Kőnig et sa contrapos\'ee, le Fan theorem. Le premier \'enonce qu'un arbre infini qui reste finiment branchant (comprendre par-là qu'à un n\oe ud donn\'e il n'y a qu'un nombre fini de fils directs) possède une branche infini ; le deuxième \'enonce que pour un arbre $T$, si toute branche infinie $\alpha$ sort de l'arbre à partir d'une longueur $n_\alpha$, alors on peut trouver un $n$ uniforme tel que toute branche infini $\alpha$ sort de $T$ à partir de la longueur $n$~: autrement dit, l'arbre a une hauteur finie. Sans rentrer dans les d\'etails, en consid\'erant un arbre comme une partie de $\bN^*$ close par pr\'efixe (son compl\'ementaire est donc une partie de $\bN^*$ close par extension), on peut \'enoncer le lemme de Kőnig et le Fan theorem de la façon suivante (en omettant plusieurs hypothèses sur $T$, respectivement $C$)~:
% \[\KL \defeq (\forall n^{\bN}, \exists p^{\bN^*}, |p| = n \land p \in T) \implies \exists \alpha^{\bN\to\bN}, \forall n^{\bN}, \alpha_0\ldots\alpha_{n-1}\in T\]
% \[\FT \defeq (\forall \alpha^{\bN\to\bN}, \exists n^\bN, \alpha_0\ldots \alpha_{n-1}\in C)\implies \exists n^\bN, \forall \alpha^{\bN\to\bN}, \alpha_0\ldots\alpha_{n-1}\in T\]
% L'\'ecriture $\exists p^{\bN^*},|p| = n \land p \in T$ est \'equivalente à $\exists \alpha^{\bN\to\bN}, \alpha_0\ldots\alpha_{n-1}\in T$, mais plus naturelle à consid\'erer. On suppose ici que $T$ est clos par pr\'efixe et $C$ par extension, nous donnant donc que $\FT$ est la contrapos\'ee de $\KL$.
%
% Mentionnons que $\KL$ comme $\FT$ sont toujours vrais dans $\ZFC$, et même dans $\ZF$~: on travaille donc dans une th\'eorie plus faible dans laquelle on peut \'etudier l'ajout de $\FT$ ou $\KL$ comme non trivial. La th\'eorie habituellement utilis\'ee en math\'ematiques à rebours est un fragment faible de l'arithm\'etique du second ordre nomm\'ee $\RCAO$. Cette th\'eorie est très expressive car elle permet de d\'ecrire les r\'eels ainsi que les fonctions continues voire mesurables. Cependant, cette expressivit\'e se fait au coût d'une grande quantit\'e de codages, qui nous int\'eressent peu. Nous faisons donc le choix de travailler dans une version de l'arithm\'etique dans laquelle on peut parler de façon interne de fonctions, de paires et d'autres outils primitifs en plus des entiers, le tout avec une logique du second ordre.
%
% Maintenant que le contexte est plus clair, nous pouvons d\'ecrire l'objectif du stage pr\'esent\'e dans ce rapport~: il s'agit de mesurer le contenu logique et calculatoire de $\FT$, en le s\'eparant notamment de $\KL$. Pour ce faire, nous utilisons la r\'ealisabilit\'e, qui est un outil reliant les langages de programmation et la logique.
%
% Depuis la d\'ecouverte de la correspondance de Curry-Howard, en effet, le lien entre les langages de programmation et la logique ont \'et\'e longuement explor\'es. Cette correspondance \'etablit un parallèle entre, d'un côt\'e, les programmes d'un langage typ\'e (par exemple un programme doublant sont entr\'ee, qu'on pourrait \'ecrire $\double : \intt \to \intt$) et les preuves d'une proposition. A une proposition $A$ il est possible de faire correspondre un type $A'$, et les programmes de types $A'$ correspondent alors à des preuves de $A$. La r\'ealisabilit\'e \'etend cette correspondance en consid\'erant, plutôt que la relation de typage, syntaxique, une approche s\'emantique. On entend par-là que la relation de typage est d\'efinie par un ensemble simple de règles d'inf\'erences, que l'on peut v\'erifier m\'ethodiquement, et que v\'erifier si un certain programme est d'un type donn\'e est en g\'en\'eral un problème d\'ecidable. La r\'ealisabilit\'e, elle, remplace la relation de typage $t : A'$ par une relation, directement entre $t$ et $A$ (la proposition), que l'on note $t \real A$, et qui signifie que $t$ est une preuve de $A$. Dans cette d\'efinition, on autorise les termes à être par exemple non typ\'es, et le seul critère consid\'er\'e pour dire que $t \real A$ est le comportement (la s\'emantique) de $t$. Avec cette relation, il devient alors possible de d\'efinir une nouvelle notion de modèle~: plutôt que d'attribuer à une proposition une valeur de v\'erit\'e dans $\{0,1\}$, la valeur de v\'erit\'e de $A$ devient l'ensemble de ses preuves, qu'on appellera ses r\'ealiseurs.
%
% Partant d'un langage simple (le $\lambda$-calcul), nous allons construire un modèle de r\'ealisabilit\'e v\'erifiant Fan theorem mais invalidant le lemme de Kőnig (sous une forme faible). La preuve que ce modèle v\'erifie $\FT$ pourra ensuite servir à chercher une pr\'esentation plus g\'en\'erale de l'argument qu'une forme de continuit\'e des fonctions calculables implique $\FT$, qui semble être une notion de continuit\'e des fonctions. En effet, il existe des cadres de travail plus g\'en\'eraux pour parler de r\'ealisabilit\'e, et extraire l'argument derrière la v\'erification de $\FT$ nous permettrait alors, en employant un de ces cadres de travail (en particulier les evidenced frames d\'ecrites dans \cite{CohMiqTat21}), d'extraire la notion calculatoire qui permet de v\'erifier ou non $\FT$.
%
% La principale contribution de ce stage, qui explique d'ailleurs le point de vue d\'evelopp\'e dans ce rapport, est la d\'efinition d'un modèle de r\'ealisabilit\'e pour aborder la r\'ealisabilit\'e permettant, plus tard, d'\'etudier les principes de choix. La construction de modèles de r\'ealisabilit\'e est un exercice classique~: on peut par exemple retrouver plusieurs modèles dans \cite{Dinis_2023} ou dans \cite{COHEN201987}, mais ceux-ci sont utilis\'es dans un objectif diff\'erent du nôtre. Le modèle que nous construisons a l'avantage d'être facilement expressif (peu de codage doit être employ\'e) et modulaire (on peut modifier une partie du modèle, comme le langage de programmation ou la syntaxe, avec un impact minime sur les autres parties).
