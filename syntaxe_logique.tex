\subsection{HOL Model}

The model we construct is based on higher order logic (HOL). This is a multi-sorted logic with a sort $\Prop$ denoting the set of propositions (hence the higher order qualification).

The choice of HOL as our syntax is mainly motivated by its expressiveness. In HOL, it is possible to easily talk about property about sets over a given sort $S$, by the sort $S \to \Prop$. Using this logic and the basic sorts $\Nat/\Bool/\List$ makes it easy to state $\FT,\WKL$ and many other importants principles.

\begin{definition}[Sorts]
  We define the set of sorts $\Sort$ inductively by:
  \[S,T \Coloneq \Nat \mid \Bool \mid \List(S)\mid S \times T \mid S \to T \mid \Prop\]
\end{definition}

With this set of sorts, we give a syntax for well-typed terms. We use bold font for the syntactic HOL terms, to distinguish them from the $\lambda$-calculus terms we introduce later. The only exception is to denote an element in $\Prop$, for which we use $\varphi,\psi\ldots$

The HOL term constructors are akin to system T: there is a constructor for abstraction and application for functions, constructors for pairing and projections, canonical constructors and recursor for our data types ($\Nat,\Bool,\List$). The main difference is on the logical aspect, as we also add propositional constructors. Those constructors are the conjunction $\land$, the implication $\to$, the two quantifications $\forall/\exists$ and the construction $\sortPred{\termt}$.

This last construction is used to underline the standard elements and to give them a computational meaning. For example, the difference between $\forall \varx^{\Nat},\varphi(\varx)$ and $\forall \varx^{\Nat},\sortPredS{\Nat}{\varx} \to \varphi(\varx)$ is that the second proposition can be proved by a computation depending on the integer $\varx$, meanwhile the first one must be proved by a proof of $\varphi$ uniform on $\varx$.

\tlnote{Maybe ignore this definition, it's straightforward.}
\begin{definition}[HOL-context]
  We fix a denumerable set $\Xt$ of variables which we denote by $\varx,\vary,\ldots$ A (HOL-)context is a list of pairs $(\varx : S)$ where $\varx \in \Xt$ and $S \in \Sort$. We denote the set of (HOL-)contexts by $\Hctx$ and will write its elements $\Gamma,\Delta,\ldots$
\end{definition}

\begin{definition}[HOL-terms]
  A well-typed (HOL-)term in a context $\Gamma$ is defined by the following inductive relation:
  \begin{center}
  \ruleUnary{$(\varx : S) \in \Gamma$}{$\Gamma\vdash \varx : S$}
  \qquad
  \ruleUnary{$\Gamma, \varx : S \vdash \termt : T$}{$\Gamma\vdash \termlam \varx.\termt : S \to T$}
  \qquad
  \ruleBinary{$\Gamma\vdash\termt : S \to T$}{$\Gamma\vdash\termu : S$}{$\Gamma\vdash \termt(\termu) : T$}
  
  \vspace{0.2cm}
  \ruleBinary{$\Gamma \vdash \termt : S$}{$\Gamma\vdash \termu : T$}{$\Gamma \vdash \langle \termt, \termu \rangle : S \times T$}
  \qquad
  \ruleUnary{$\Gamma\vdash \termt : S \times T$}{$\Gamma\vdash \termpi_1(\termt) : S$}
  \qquad
  \ruleUnary{$\Gamma\vdash \termt : S \times T$}{$\Gamma\vdash \termpi_2(\termt) : T$}

  \vspace{0.2cm}
  \ruleAx{$\Gamma\vdash \termZ : \Nat$}
  \qquad
  \ruleUnary{$\Gamma\vdash \termt : \Nat$}{$\Gamma\vdash S(\termt) : \Nat$}

  \vspace{0.2cm}
  \ruleTernary{$\Gamma\vdash \termt : S$}{$\Gamma\vdash \termu : \Nat \to S \to S$}{$\Gamma\vdash \termv : \Nat$}{$\Gamma\vdash \termrec_{\Nat}(\termt,\termu,\termv) : S$}

  \vspace{0.2cm}
  \ruleAx{$\Gamma\vdash \termtt : \Bool$}
  \qquad
  \ruleAx{$\Gamma\vdash \termff : \Bool$}
  
  \vspace{0.2cm}
  \ruleTernary{$\Gamma\vdash \termt : S$}{$\Gamma\vdash \termu : S$}{$\Gamma\vdash \termv : \Bool$}{$\Gamma\vdash \termrec_{\Bool}(\termt,\termu,\termv) : S$}

  \vspace{0.2cm}
  \ruleAx{$\Gamma\vdash \termnil : \List(S)$}
  \qquad
  \ruleBinary{$\Gamma\vdash \termt : S$}{$\Gamma\vdash \termu : \List(S)$}{$\Gamma\vdash \termt\termcons\termu : \List(S)$}

  \vspace{0.2cm}
  \ruleTernary{$\Gamma\vdash \termt : T$}{$\Gamma\vdash \termu : S \to \List(S) \to T \to T$}{$\Gamma\vdash \termv : \List(S)$}{$\Gamma\vdash \termrec_{\List(S)}(\termt,\termu,\termv) : T$}

  \vspace{0.2cm}
  \ruleBinary{$\Gamma\vdash \varphi : \Prop$}{$\Gamma\vdash \psi : \Prop$}{$\Gamma\vdash \varphi \to \psi : \Prop$}

  \vspace{0.2cm}
  \ruleBinary{$\Gamma\vdash \varphi : \Prop$}{$\Gamma\vdash \psi : \Prop$}{$\Gamma\vdash \varphi \land \psi : \Prop$}

  \vspace{0.2cm}
  \ruleUnary{$\Gamma, \varx : S \vdash \varphi : \Prop$}{$\Gamma\vdash \forall \varx^S, \varphi : \Prop$}
  \qquad
  \ruleUnary{$\Gamma, \varx : S \vdash \varphi : \Prop$}{$\Gamma\vdash \exists \varx^S, \varphi : \Prop$}

  \vspace{0.2cm}
  \ruleUnary{$\Gamma\vdash : \termt : S$}{$\Gamma \vdash \sortPred{\termt} : \Prop$}
  \end{center}
\end{definition}

A model of such a syntax must give a semantic interpretation of each sort. In particular, there must be an interpretation for the sort $\Prop$. From the constructors of this sort, the interpretation of $\Prop$ must have a function interpreting $\land$ and $\to$, and a function interpreting $\forall$ and $\exists$. We postpone the introduction of the exact interpretation of $\Prop$, and parametrize the model by a Heyting pre-algebra $H$ equiped with two functions $\powerset (H) \to H$. Finally, to interpret $\Prop$, we need an interpretation of $\sortPred{\termt}$, for which we add an abstract encoding function $\cod -$ giving for each interpretation of a term an object of $H$.
The other sorts are given their natural set theoretic semantic.

\begin{definition}[Semantic]
  Let $(H,\leqH)$ be a Heyting algebra with an intersection and a union operations $\bigcup,\bigcap : \powerset (H) \to H$.
  For each sort $S \in \Sort$, we associate a set $\sem S$:
  \begin{itemize}
  \item $\sem{\Nat} \defeq \bN$
  \item $\sem{\Bool} \defeq \bB$
  \item $\sem{\List(S)} \defeq \sem S ^\star$
  \item $\sem{S \times T} \defeq \sem S \times_{\Set} \sem T$
  \item $\sem{S \to T} \defeq {\sem T}^{\sem S}$
  \item $\sem{\Prop} \defeq H$
  \end{itemize}

  Let
  \[\begin{array}{ccccc}
  \cod - &:& \bigcup_{S \in \Sort} \sem{S} & \longrightarrow & H \\
  & & s &\longmapsto & \cod s
  \end{array}\]
  be a function associating to each object a set of codes (possibly empty).

  Each well-typed term $\Gamma \vdash \termt : S$ is mapped to its semantic
  \[
  \sem{\Gamma \vdash \termt : S} : \prod_{T \in \Gamma} \sem T \longrightarrow \sem S
  \]
  by the following interpretation:
  \begin{itemize}
  \item $\sem{\varx_1 : S_1,\cdots , \varx_n : S_n\vdash \varx_i : S_i} \defeq \pi_i^n$
  \item
    \begin{multline*}
      \sem{\Gamma \vdash \termlam \varx.\termt : S \to T} \defeq \\
      (x \in \sem S) \mapsto (\overrightarrow{x} \in \sem \Gamma) \mapsto \sem{\Gamma, \varx : S\vdash \termt : T}(\overrightarrow{x},x)
    \end{multline*}
  \item $\sem{\Gamma\vdash \termt(\termu) : T} \defeq \eval\circ \langle\sem{\Gamma\vdash \termt : S \to T}, \sem{\Gamma\vdash \termu : S}\rangle$
  \item $\sem{\Gamma\vdash \langle \termt,\termu\rangle : S \times T} \defeq \langle \sem{\Gamma\vdash \termt : S}, \sem{\Gamma\vdash \termu : T}\rangle$
  \item $\sem{\Gamma\vdash \termpi_1(\termt) : S} \defeq \pi_1 \circ \sem{\Gamma\vdash \termt : S \times T}$
  \item $\sem{\Gamma\vdash \termpi_2(\termt) : S} \defeq \pi_2 \circ \sem{\Gamma\vdash \termt : S \times T}$
  \item $\sem{\Gamma\vdash \termZ : \Nat} \defeq (\overrightarrow{x} \in \sem\Gamma) \mapsto 0$
  \item $\sem{\Gamma\vdash S(\termt) : \Nat} \defeq (n \mapsto n + 1) \circ \sem{\Gamma\vdash \termt : \Nat}$
  \item
    \begin{multline*}
      \sem{\Gamma\vdash \termrec_{\Nat}(\termt,\termu,\termv) : S} \defeq \\
      \rec_{\bN}\circ\langle\sem{\Gamma\vdash \termt : S}, \sem{\Gamma\vdash \termu : \Nat \to S \to S}, \sem{\Gamma\vdash \termv : \Nat}\rangle
    \end{multline*}
  \item $\sem{\Gamma\vdash \termtt : \Bool} \defeq (\overrightarrow x \in \sem{\Gamma}) \mapsto \top$
  \item $\sem{\Gamma\vdash \termff : \Bool} \defeq (\overrightarrow x \in \sem{\Gamma}) \mapsto \bot$
  \item
    \begin{multline*}
      \sem{\Gamma\vdash \termrec_{\Bool}(\termt,\termu,\termv) : S} \defeq \\
      \rec_{\bB}\circ\langle\sem{\Gamma\vdash \termt : S}, \sem{\Gamma\vdash \termu : S}, \sem{\Gamma\vdash \termv : \Bool}\rangle
    \end{multline*}
  \item $\sem{\Gamma\vdash \termnil : \List(S)} \defeq (\overrightarrow x \in \sem{\Gamma}) \mapsto \varepsilon$
  \item $\sem{\Gamma\vdash \termt \termcons \termu : \List(S)}\defeq \smallfrown \circ \langle\sem{\Gamma\vdash \termt : \List(S)},\sem{\Gamma\vdash\termu : S}\rangle$
  \item
    \begin{multline*}
      \sem{\Gamma\vdash\termrec_{\List(S)}(\termt,\termu,\termv) : T} \defeq\\
      \rec_{\bL}\circ\langle\sem{\Gamma\vdash \termt : T}, \sem{\Gamma\vdash \termu : S \to \List(S) \to T \to T}, \sem{\Gamma\vdash \termv : \List(S)}\rangle
    \end{multline*}
  \item $\sem{\Gamma\vdash \varphi \to \psi : \Prop} \defeq \implH\circ\langle\sem{\Gamma\vdash \varphi : \Prop},\sem{\Gamma\vdash \psi : \Prop}\rangle$
  \item $\sem{\Gamma\vdash \varphi \to \psi : \Prop} \defeq \landH\circ\langle\sem{\Gamma\vdash \varphi : \Prop}, \sem{\Gamma\vdash \psi : \Prop}\rangle$
  \item $\displaystyle\sem{\Gamma\vdash \forall \varx^S, \varphi : \Prop} \defeq (\overrightarrow x \in \sem{\Gamma}) \mapsto \bigcap_{s \in \sem S} \sem{\Gamma, \varx : S\vdash \varphi : \Prop}(\overrightarrow x, s)$
  \item $\displaystyle\sem{\Gamma\vdash \exists \varx^S, \varphi : \Prop} \defeq (\overrightarrow x \in \sem{\Gamma}) \mapsto \bigcup_{s \in \sem S} \sem{\Gamma, \varx : S\vdash \varphi : \Prop}(\overrightarrow x, s)$
  \item $\sem{\Gamma\vdash \sortPred{\termt} : \Prop} \defeq \cod - \circ \sem{\Gamma\vdash \termt : S}$
  \end{itemize}
  where $\termrec_{\bN}$ (resp. $\termrec_{\bB}$, resp. $\termrec_{\bL}$) are the canonical recurcors given by the initial algebra structure of $\bN$ (resp. $\bB$, resp. $\sem S^\star$), $\smallfrown$ is the operation which, given a letter $a$ and a word $u$, appends $a$ to $u$ to make a new word, $\implH$ is the implication of $H$ and $\landH$ is its meet.

  For a given sort $S$, we will also write $\bS$ for $\sem S$.
\end{definition}

In all generality, the syntactic terms are given in a typing context, like $\Gamma\vdash \termt : S$. Thus, to construct an element of $\bS$, we need an environment $\rho$ which covers $\Gamma$.

\begin{notation}
  Given a HOL-context $\Gamma$ and a function $\displaystyle\termenv : \Xt \partialto \bigcup_{S \in \Sort} \bS$, we define
  \[\termenv\models \Gamma \defeq \forall (\varx : S) \in \Gamma, \termenv(\varx) \in \bS\]
  If $\Gamma \vdash \termt : S$ and $\termenv\models \Gamma$, then we write $\termenv(\termt)$ for the canonical element in $\bS$ associatied to this term.
\end{notation}
