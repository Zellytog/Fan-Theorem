
The model we construct is based on higher-order logic (HOL). This is a multi-sorted logic with a sort $\Prop$ denoting the set of propositions (hence the higher order qualification).
The choice of HOL as our syntax is mainly motivated by its expressiveness. In HOL, it is possible to easily talk about predicates on sets over a given sort $S$, by the sort $S \to \Prop$. %Using this logic and the basic sorts $\Nat/\Bool/\List$ makes it easy to express statements about trees (which are predicates on lists) such as  $\FT$ and $\WKL$.


In realizability models, universal quantifications are usually interpreted as intersections without computational content, for instance having truth values of first-order universal quantifications satisfying $|\forall x,\varphi(x)|=\bigcap_{n\in\bN}|\varphi(n)|$. In particular, a realizer in $|\forall x,\varphi(x)|$ should realize $\varphi(n)$ for any $n\in\bN$ \emph{without} knowing the value of $n$. Dually, realizers of existential statements witness the existence of a valid instantiation for the existentially quantified variable without actually computing its value.
However, we seek a computational interpretation of the Fan Theorem such that \emph{its realizer actually computes} the uniform bound for the bar.
To overcome this, we rely on a standard technique and use \emph{relativized quantifications}: instead of $\forall x,\varphi(x)$, we consider
formulas of the shape $\forall x,\sortPredS{\Nat}{x} \to \varphi(x)$, where the proposition $\sortPredS{\Nat}{x}$ states that $x$ is indeed a natural. A realizer of this statement will now have to realize  $\sortPredS{\Nat}{n}\to \varphi(n)$, that is to realize $\varphi(n)$ provided a realizer of $\sortPredS{\Nat}{n}$, \emph{i.e.} a term computing the value of $n$. The realizability model is introduced in \Cref{s:realizability}, we begin with the definition of HOL formulas for our interpretation.

In order for our realizers to compute with trees, that is with path (via functions in $\bN\to\bB$), prefixes of paths (\emph{i.e.} lists on booleans) and (decidable) sets of lists, we therefore consider sorts accounting for natural numbers, lists, booleans, propositions and functions, while formulas are usual HOL propositions extended with a relativization predicate for each sort.

% This last construction is used to underline the standard elements and to give them a computational meaning. For example, the difference between $\forall \varx^{\Nat},\varphi(\varx)$ and $\forall \varx^{\Nat},\sortPredS{\Nat}{\varx} \to \varphi(\varx)$ is that the second proposition can be proved by a computation depending on the integer $\varx$, meanwhile the first one must be proved by a proof of $\varphi$ uniform on $\varx$.

\begin{definition}[Sorts]
  The set of sorts $\Sort$ is inductively defined by:
  \[S,T \Coloneq \Nat \mid \Bool \mid \List(S)\mid S \times T \mid S \to T \mid \Prop\]
\end{definition}

% \begin{definition}[HOL terms]
%  HOL formulas are inductively defined by :
%   \[\begin{array}{rcl}
%   \termt,\termu &\Coloneq &\varx \mid  \termlam \varx.\termt \mid \termt(\termu) \mid  \langle \termt, \termu \rangle \mid \termpi_1(\termt)
%   \mid \termpi_2(\termt)\\
%   &\mid&
%   \termZ \mid S(\termt)
%   \mid \termrec_{\Nat}(\termt,\termu,\termv)\\
%   &\mid&\termtt
%   \mid \termff
%   \mid \termrec_{\Bool}(\termt,\termu,\termv) \\
%   &\mid& \termnil
%   \mid \termt\termcons\termu
%   \mid \termrec_{\List(S)}(\termt,\termu,\termv)
%   \end{array}\]
% \end{definition}


\begin{definition}[Formulas]
 Formulas are inductively defined by:
  $$\varphi,\psi \Coloneq S(\termt) \mid \varphi\to\psi \mid \varphi \land \psi \mid \forall x^S,\varphi \mid \exists x^S,\varphi \eqno(S\in\Sort)$$
where $\termt$ is a HOL-term (\textit{c.f.} \Cref{def:hol_terms})
\end{definition}

With this set of sorts, we give a syntax for well-typed terms. We use bold font for the syntactic HOL terms, to distinguish them from the $\lambda$-calculus terms we introduce later. The only exception is to denote an element in $\Prop$, for which we use $\varphi,\psi\ldots$

The HOL term constructors are akin to system T: there is a constructor for abstraction and application for functions, constructors for pairing and projections, canonical constructors and recursor for our data types ($\Nat,\Bool,\List$). The main difference is on the logical aspect, as we also add propositional constructors for the formula above.
% Those constructors are the conjunction $\land$, the implication $\to$, the two quantifications $\forall/\exists$ and the construction $\sortPred{\termt}$.
% \tlnote{Maybe ignore this definition, it's straightforward.}
% \begin{definition}[HOL-context]
  As usual, we fix a denumerable set $\Xt$ of variables which we denote by $\varx,\bvary,\ldots$ and we define \emph{(HOL-)contexts} as lists of pairs $(\varx : S)$ where $\varx \in \Xt$ and $S \in \Sort$. We denote the set of (HOL-)contexts by $\Hctx$ and will write its elements $\Gamma,\Delta,\ldots$
% \end{definition}


\begin{definition}[HOL-terms]
  \label{def:hol_terms}
  A well-typed (HOL-)term $\termt$ of sort $S$ in a context $\Gamma$, which we denote by $\Gamma\vdash \termt:S$, is defined by the inductive relation given in Figure 1.%\ref{fig:hol_terms}.
  \end{definition}
  \begin{figure}[t]
  \begin{center}
  \ruleUnary{$(\varx : S) \in \Gamma$}{$\Gamma\vdash \varx : S$}
  \quad
  \ruleUnary{$\Gamma, \varx : S \vdash \termt : T$}{$\Gamma\vdash \termlam \varx.\termt : S \to T$}

   \vspace{0.2cm}

  \ruleBinary{$\Gamma\vdash\termt : S \to T$}{$\Gamma\vdash\termu : S$}{$\Gamma\vdash \termt(\termu) : T$}
\quad
  \ruleBinary{$\Gamma \vdash \termt : S$}{$\Gamma\vdash \termu : T$}{$\Gamma \vdash \langle \termt, \termu \rangle : S \times T$}

   \vspace{0.2cm}
  \ruleUnary{$\Gamma\vdash \termt : S \times T$}{$\Gamma\vdash \termpi_1(\termt) : S$}
  \quad
  \ruleUnary{$\Gamma\vdash \termt : S \times T$}{$\Gamma\vdash \termpi_2(\termt) : T$}

  \vspace{0.2cm}
  \ruleAx{$\Gamma\vdash \termZ : \Nat$}
  \quad
  \ruleUnary{$\Gamma\vdash \termt : \Nat$}{$\Gamma\vdash \termS(\termt) : \Nat$}
  %\quad

  \vspace{0.2cm}
  \ruleTernary{$\Gamma\vdash \termt : S$}{$\Gamma\vdash \termu : \Nat \to S \to S$}{$\Gamma\vdash \termv : \Nat$}{$\Gamma\vdash \termrec_{\Nat}(\termt,\termu,\termv) : S$}

  \vspace{0.2cm}
  \ruleAx{$\Gamma\vdash \termtt : \Bool$}
  \quad
  \ruleAx{$\Gamma\vdash \termff : \Bool$}
  %\quad

  \vspace{0.2cm}
  \ruleTernary{$\Gamma\vdash \termt : S$}{$\Gamma\vdash \termu : S$}{$\Gamma\vdash \termv : \Bool$}{$\Gamma\vdash \termrec_{\Bool}(\termt,\termu,\termv) : S$}

  \vspace{0.2cm}
  \ruleAx{$\Gamma\vdash \termnil : \List(S)$}
  \quad
  \ruleBinary{$\Gamma\vdash \termt : S$}{$\Gamma\vdash \termu : \List(S)$}{$\Gamma\vdash \termt\termcons\termu : \List(S)$}
  %\quad
  \vspace{0.2cm}
  \ruleTernary{$\Gamma\vdash \termt : T$}{$\Gamma\vdash \termu : S \to \List(S) \to T \to T$}{$\Gamma\vdash \termv : \List(S)$}{$\Gamma\vdash \termrec_{\List(S)}(\termt,\termu,\termv) : T$}

  \vspace{0.2cm}
  \ruleBinary{$\Gamma\vdash \varphi : \Prop$}{$\Gamma\vdash \psi : \Prop$}{$\Gamma\vdash \varphi \to \psi : \Prop$}
  \quad
  \ruleUnary{$\Gamma, \varx : S \vdash \varphi : \Prop$}{$\Gamma\vdash \forall \varx^S, \varphi : \Prop$}

  \vspace{0.2cm}
  \ruleBinary{$\Gamma\vdash \varphi : \Prop$}{$\Gamma\vdash \psi : \Prop$}{$\Gamma\vdash \varphi \land \psi : \Prop$}
  \quad%\vspace{0.2cm}
  \ruleUnary{$\Gamma, \varx : S \vdash \varphi : \Prop$}{$\Gamma\vdash \exists \varx^S, \varphi : \Prop$}

  \vspace{0.2cm}
  \ruleUnary{$\Gamma\vdash : \termt : S$}{$\Gamma \vdash \sortPred{\termt} : \Prop$}
  \end{center}
   \label{fig:hol_terms}
   \caption{Well-typed HOL terms}   %\emnote{put in a figure*?}
  \end{figure}
% \end{definition}

A model of such a syntax must give a semantic interpretation of each sort. In particular, there must be an interpretation for the sort $\Prop$. From the constructors of this sort, the interpretation of $\Prop$ must have a function interpreting $\land$ and $\to$, and functions interpreting $\forall$ and $\exists$. We postpone the introduction of the exact interpretation of $\Prop$, and parametrize the model by a Heyting pre-algebra $H$ equipped with two functions $\bigcap,\bigcup : \powerset (H) \to H$ representing unions and intersections. Finally, to interpret $\Prop$, we need an interpretation of $\sortPred{\termt}$, for which we add an abstract encoding function $\cod -$ giving for each interpretation of a term an object of $H$.
The other sorts are given their natural set theoretic semantics.

\begin{definition}[Semantics]\label{def:sem}
  Let $(H,\leqH)$ be a Heyting pre-algebra with an intersection and a union operation $\bigcup,\bigcap : \powerset (H) \to H$.
  For each sort $S \in \Sort$, we associate a set $\sem S$:
  \begin{multicols}{2}
  \begin{itemize}
  \item $\sem{\Nat} \defeq \bN$
  \item $\sem{\Bool} \defeq \bB$
  \item $\sem{\List(S)} \defeq \sem S ^\star$
  \item $\sem{S \times T} \defeq \sem S \times_{\Set} \sem T$
  \item $\sem{S \to T} \defeq {\sem T}^{\sem S}$
  \item $\sem{\Prop} \defeq H$
  \end{itemize}
  \end{multicols}
  \noindent Let
  \[\begin{array}{ccccc}
  \cod - &:& \bigcup_{S \in \Sort} \sem{S} & \longrightarrow & H \\
  & & s &\longmapsto & \cod s
  \end{array}\]
  be a function associating to each object a set of codes (possibly empty).
  Each well-typed term $\Gamma \vdash \termt : S$ is mapped to its semantics
  \[
  \sem{\Gamma \vdash \termt : S} : \prod_{T \in \Gamma} \sem T \longrightarrow \sem S
  \]
  by the usual set-theoretic interpretation (the complete definition is given in \Cref{app:hol_semantic}). For example,
  \begin{multline*}
  \sem{\Gamma\vdash \termlam\varx.\termt : S \to T} \defeq\\
  (x \in \sem S) \mapsto \overrightarrow{x} \in \sem\Gamma) \mapsto \sem{\Gamma,\varx : S\vdash \termt : T}(\overrightarrow{x},x)
  \end{multline*}
  while we interpretation $\Gamma\vdash \sortPred \termt : \Prop$ as $\cod - \circ \sem{\Gamma\vdash \termt : S}$.

  For a given sort $S$, we will also write $\bS$ for $\sem S$.
\end{definition}

In all generality, the syntactic terms are given in a typing context, like $\Gamma\vdash \termt : S$. Thus, to construct an element of $\bS$, we need an environment $\rho$ which covers $\Gamma$.

\begin{notation}
  Given a HOL-context $\Gamma$ and a function $\displaystyle\termenv : \Xt \partialto \bigcup_{S \in \Sort} \bS$, we define
  \[\termenv\models \Gamma \defeq \forall (\varx : S) \in \Gamma, \termenv(\varx) \in \bS\]
  If $\Gamma \vdash \termt : S$ and $\termenv\models \Gamma$, then we write $\termenv(\termt)$ for the canonical element in $\bS$ associatied to this term.
\end{notation}
