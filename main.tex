% \providecommand{\mode}{-1} %% Neutre
% \providecommand{\mode}{0} %% FSCD
\providecommand{\mode}{1} %% LICS



\newcommand\switch[3]{%
  \ifcase\mode\relax
    #1
  \or
    #2
  \or
\else
    #3
  \fi
}
\newcommand\iflics[2]{\ifcase\mode\relax #2 \or #1 \else #2\fi}


\switch{
\input{header_fscd}
}{
\input{header_lics}
}{
\input{header}

}

\usepackage{refcount}

\usepackage{macros}
\newcommand{\ciseau}{\ccnote{\ding{33}}}

\Crefname{proposition}{Proposition}{Definitions}
\begin{document}
\title[Oracles Just for Fan]{Oracles Just for Fan:\\ A Robust
Computational Interpretation of the Fan Theorem}

\iflics{\input{authorLICS}}{}

\maketitle
\iflics{}{\begin{abstract}
 \input{abstract}
\end{abstract}}


\section{Introduction}

\input{introduction.tex}

%
% \emnote{je ferais peut-etre une division : section 2 - la logique (actuelle 2.1),
% et le language des termes pour calculer avec les objets mathématiques,
% en expliquant au préalable l'importance des quantifications relativisées
% et donc notre envie de bien séparer ce langage}
%
% \emnote{ensuite je ferais sec 3 - réalisabilité, en donnant au préalable
% une description avec les mains du réaliseur attendu (boucle, terminaison parce que
% sinon chemin infini, on veut le calculer (oracles) et alors par continuité...), justifiant du coup le besoin
% d'oracles et de kripke}

\section{A computably relevant syntax for trees}%{Computing with Trees: HOL and Sorts}
\label{s:HOL}
%\emnote{titre à améliorer}

\input{syntaxe_logique.tex}



\section{The realizability model}
\label{s:realizability}

%\emnote{ici description informelle preuve et réaliseur attendu (boucle, terminaison parce que
%sinon chemin infini, on veut le calculer (oracles) et alors par continuité...), justifiant du coup le besoin
%d'oracles et de kripke}

From a naive realizability model, the main issue to realize $\FT$ is
that a barred tree can be very ill-behaved.
For example, a tree can have arbitrary long finite paths,
as long as any infinite path is non computable.
The solution we adopt is to construct a realizability relation accounting
for possibly non-computable infinite paths:
using a semantics similar to Kripke semantic, the trees are forced to be
compatible with paths yet to be defined.
Then, we add infinite paths in the computational model by fixing
primitives $\oracle$ and a reduction rule $\oracle\;\encode n \redi \encode{\alpha(n)}$
where $\alpha$ is the infinite path we wish to add in the model.

Using this realizability notion, the algorithm realizing $\FT$ is an extensive
search among the finite binary words using the bar $b$ given as parameter.
For each natural number $n$, the algorithm tests whether $n$ is a uniform bound
for the predicate $B$.
Thus, two cases can appear:
\begin{itemize}
\item the algorithm can stop at some $n$.
In this case, $n$ is a uniform bound, so the algorithm indeed realizes a uniform bound by returning $n$
\item the algorithm can go on indefinitely.
This means that for any $n$, not every word of size $n$ satisfies the predicate,
hence that there is a word $w_n\in \bB^n \setminus B$ for any $n$.
In the meta-theory, we can then extract an infinite path $\alpha \notin B$
using $\WKL$: as $B$ is taken as the complementary of a tree,
the words not in $B$ constitute a binary tree.
This is the point where the oracles come into play:
we can now use an oracle $\oracle$ to simulate $\alpha$,
and the Kripke semantic allows $b$ to take as argument the term $\oracle$.
Thus, we wish our Kripke-like semantic to be defined such that $b$ realizing
a bar on $B$ not only means that $b$ computes as a bar in some context,
but also that it does so in any bigger context
(taken as a notion of future world). Finally, using a continuity argument, computing $b(\oracle)$ can be done only for a finite part of $\oracle$, which was already treated in the computation of the original algorithm, giving that both $B(\oracle)$ holds (because it extends the prefix given by a bar on $B$) and that $B(\oracle)$ does not hold (by our choice of $\alpha$).
\end{itemize}
To build a realizability model replicating this argument, we thus need to
implement oracles but also to structure the realizability relation
in a Kripke-like way: realizing $\varphi \to \psi$ not only means
that realizers of $\varphi$ are sent to realizers of $\psi$
for some given world (taken here to be context of functions working as oracles)
but also for future worlds (extensions of this context).


\subsection{Lambda-calculus}
\label{}
\input{lambda_calculus.tex}

\subsection{Realizability relation}
\label{}
\input{realizability_relation.tex}

\subsection{Adequacy}
\label{}
\input{adequacy.tex}

\section{A Realizer for the Fan Theorem}
\label{s:FT}
With our model constructed, and the proof that it describes
a consistent theory done, we are now ready to prove
that this model satisfies $\FT$. We also show
that $\WKL$ fails with a standard argument using a Kleene tree.
We start by defining precisely these principles, before going through a comprehensive
construction of the program that we use to realize \FT.
\subsection{Fan Theorem \& Weak \Konig's Lemma}
%\emnote{def + discussion sur binaire ou non, et renvoi à ~\cite{BreHer21}}

Now that we know both the logic we use and the model we consider,
let us give a formal definition of $\FT$.
We assume given the function $\restr \alpha \varn$ which is the
prefix of the $n$ first values of $\alpha$, given in a list,
and write $\ListInf$ for the prefix order on lists.

As we mentionned before, $\FT$ applies to the complement of a tree.
The way we formalize trees can vary, but in reverse mathematics and computability
it is standard to consider a tree as a predicate $T \subseteq \List(\bN)$
(where $\List$ is used in place of the set of finite words) closed by prefix,
meaning that $\ell \ListInf \ell' \implies \ell' \in T \implies \ell \in T$.
This means that the complement of a tree must satisfy the converse,
which we call a monotonous predicate:
\[\Mono^S(B) \defeq \forall \ell^{\List(S)}\,{\ell'}^{\List(S)}, \ell \ListInf \ell' \implies B(\ell) \implies B(\ell')\]
Naturally, when writing $\forall B^{\Mono^S}, \varphi$, we use the same relativization procedure as before.

The statement we use as $\FT$ is
\begin{multline*}
        \FT\defeq \forall B^{\Mono^\Bool}, (\forall \alpha^{\{\Nat \to \Bool\}}, \exists \varn^{\{\Nat\}}, \restr\alpha \varn \in B) \implies \\
        \exists \varn^{\{\Nat\}}, \forall \alpha^{\{\Nat\to\Bool\}}, \restr \alpha \varn \in B
\end{multline*}

$\FT$ is thus a rewriting of the contrapositive of $\WKL$, replacing a tree by its complement, a monotonous predicate. However, the statement of $\FT$ vary in the litterature. In \cite{LubRat13} on which we base our model, $\FT$ is given on binary tree the same way we do here. In \cite{BreHer21}, however, $\FT$ is stated with a finite set instead of $\Bool$: in fact, our construction perfectly works in this setting because there is no more computational difficulty in the finite case, as long as the bound on the finite set is known \textit{a priori}. Another statement, which would make $\FT$ dual to $\KL$, would be to consider $T : \List(\bN) \to \Prop$ (the complement of $B$, a tree) with a finite branching condition saying that $T \cap \bN^n$ is always a finite set, in which case our models would not satisfy the principle.

\input{bestiaire.tex}

\input{FT.tex}

\section{A robust interpretation of the Fan Theorem}
\label{s:robust}
The realizability model developed in \Cref{s:FT} relies on the ideas
of Lubarsky and Rathjen's work \cite{LubRat13} to prove $\FT$.
For the argument in this proof to work, the two main conditions that emerge are
\begin{itemize}
\item a notion of continuity for the individuals realized by a code %\emnote{of quantified relativization/individuals realized by a code}
\item having a Kripke-style notion of future worlds in which, given a tree $T$ at some world $\enviro$,
there exists a future $\enviroT$ in which a path in $T$ can be computed.
\end{itemize}
We shall now emphasize the robustness of this approach: we show that the interpretation
is actually independent of the particular choice of a computational system as long as these conditions are satisfied.
To that end, we will use the notion of \emph{evidenced frames} introduced in \cite{CohMiqTat21}.
Evidenced frames (which we will shorten as EF) are combinatorial structures encompassing
the notion of a realizability model:
roughly speaking, an EF is a triple $( \Phi, E, \relEFdot )$
where $\Phi$ is a set of formulas describing the set of truth values,
~$E$ is a set of evidences describing the realizers,
and the relation \mbox{$\cdot \xle{\cdot} \cdot$} is akin to the logical inequality $\infSAT$
where the witness is made explicit.
In particular, it has the advantage of allowing one to abstract away
from the implementation details to show that any computational system satisfying
some specifications (\emph{e.g.}, memoization features) will induce a realizability model
satisfying the expected logical principles (\emph{e.g.}, countable choice~\cite{CohMiqTat21}).
In this section, we therefore seek for a general way to state the two conditions aboves
(as well as a few others which will arise later) using EFs.

In contrast with previous works using EFs~\cite{CohMiqTat21,GarMiq23,CohGruKirMiq25EffHOL,
CohGruKirMiq25mca}, where concrete structures used to define realizability interpretations
(\textit{e.g.}, monadic combinatorial algebras) are proven to induce an EF,
here we will rather focus only on EFs:
the concrete structure we study will be introduced as an additional structure
over EFs.

This section ends with the statement of the \Cref{thm:main}, which is a more abstract
variant of the \Cref{thm:FT}: in this version, the realizability structure realizing $\FT$ can have realizers of any form ($\lambda$-terms, Turing machines\ldots) as long as it gives an implementation of integers with its recursor, satisfies the two conditions mentioned above for the argument to work,
plus two additional technical conditions.

\subsection{The induced Evidenced Frame}
\label{s:EF}
\input{EF.tex}

\subsection{A robust generalization of the proof}
\label{s:generalization}
\input{generalisation.tex}


\subsection{Application, limitations}
\label{s:application}
\input{application.tex}

\section{Conclusion, future work}
%\tlnote{Conclusion : mini récap disant qu'on a défini un modèle séparant FT et WKL. On a identifié que les éléments essentiels sont [les conditions du thm]. On montre la robustesse de l'approche et on observe que le modèle concret qu'on a défini permet de donner à nos conditions une notion propre à FT, sans WKL.}

This article introduces a realizability model separating \FT from \WKL
based on a $\lambda$-calculus extended with oracles.

% It is related to the model in \cite{LubRat13} in a similar way
% as standard $\lambda$-calculus realizability of Heyting Arithmetic
% is related to Kleene's first realizability algebra.
We provide a concrete realizer for \FT, which performs a naive extensive search for
a uniform bound. More importantly, we identify the key features of this realizability
interpretation that allow to satisfy \FT:
\begin{itemize}
\item realizers are continuous,
\item the computational system can be extended with infinite paths
for any computable tree,
\item it accounts for strong existential,
\item it features an unbounded search.
\end{itemize}
To support our claim that this computational interpretation is indeed robust, in
the sense that it does not really on other peculiarities of the underlying $\lambda$-calculus,
we formulate it in the general framework of evidenced frames.
This provides us with in a result which applies to any realizability model
exhibiting those properties.
This generality implies that the computational content we outline
is explicit and is not a degenerate case of a particular model.

Besides, we know that the argument cannot work without the second property,
because the Kleene tree in the standard realizability model (with no oracle)
has a bar which is not uniform. Nonetheless, these conditions allow the
construction of models (\textit{e.g.} the one explicitly constructed in this
article) which satisfy \FT without satisfying \WKL, indicating that they are
parcimonious at least with regard to the hierarchy established in \cite{BreHer21}.
%
%
% This theorem is also robust by stating a statement of the form
% \emph{``any computational system providing an implementation of \emph{(a)} will induce an evidenced frame validating \emph{(b)}}''.
Beyond the specific case of the Fan Theorem, we advocate for a computational approach
to constructive reverse maths, and we expect that an exploration of logical principles
can be conducted by this methodology.
Especially, we believe that a reasonable answer to the problem of
finding the computational content of a logical
principle $(b)$ should follow the same path:
\begin{itemize}
\item a general definition of computational system must be given,
and this computational system can be made into an EF
(or another general realizability framework, like implicative algebra \cite{Miquel20})
\item on this notion of computational system, we can define a condition $(a)$
such that a computational system satisfying $(a)$ always satisfies $(b)$ in the
induced realizability model
\item among the computational systems satisfying $(a)$, we can find ones
that do not satisfy a strictly stronger principle than $(b)$.
\end{itemize}
This methodology has been applied to $\FT$ in this article,
but can be transposed to any other logical principle:
first, the hierarchy of choice principles in \cite{BreHer21} is a natural
candidate, as it gives both a list of principles and a a good criterium
to exhibit what strictly stronger principle we do not expect to satisfy
(namely the principles above in the hierarchy, and the classical counterpart
of intuitionistic principles).

%The argument we made can also be adapted to prove \FT, depending of the definition we consider. If we follow \cite{LubRat13}, what we call \WFT is directly \FT, which is expected as the argument is mostly the same. However, using the definition of \FT in \cite{BreHer21}, the same argument still works: working on a fixed finite branching is not computationaly harder than working on binary trees. The case where \FT is strictly stronger than what we study in this article is when considering a tree $T$ over $\bN^{<\bN}$ such that for any $n$, $T \cap \bN^n$ is finite. In this case, the tree can have an unbounded branching which cannot be checked computationally.

%\tlnote{Ouverture : - conditions suffisantes, est-ce qu'elles sont nécessaires ? On sait quand on fait sauter le 'chemin dans le futur' que ça ne marche plus, mais pour les autres on sait pas. - est-ce qu'on est capable de faire ça pour d'autres principes de choix et monter dans la hiérarchie de Nuria et Hugo ? Sur DC avec mémoization ? Sur König ? - est-ce qu'on peut traduire les variantes de FT dans notre approche ?}

%Now, several further work can be opened. This article shows that choice principles can be studied through a general realizability framework, namely evidenced frames, to give them a computational content. The natural extension of this work is thus to find similar theorems showing what computational behavior must be exhibited to show \textit{e.g.} \WKL, \KL, \DC or some other choice principles.

Another interesting question arises when considering alternative versions of \FT. For example, it is possible to weaken the premisse that \emph{any bar must be uniform} by only considering bars on $\Pi_0^1$ trees or on computable trees. Is there a variation of the \Cref{thm:main} accounting for such weakenings?

%\cite{BreHer21}
\switch
{\bibliographystyle{plainurl}}
{\bibliographystyle{ACM-Reference-Format}}
{\bibliographystyle{plainurl}}
\bibliography{biblio}

\newpage
\onecolumn
\appendix
\input{appendix}
\end{document}
