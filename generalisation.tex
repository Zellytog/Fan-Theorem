

We will now generalize our proof of $\FT$ by abstracting its core over the
abstract framework provided by evidenced frames.
Scrutinizing the argument in the proof of \Cref{thm:FT},
besides the whole Kripke-like structure of our model,
we identify the following key ingredients:
\begin{enumerate}
\item the realizability model accounts at least for system T functions (for instance,
encodings allow one to talk about functions $\List(\Nat) \to \Bool$),
\item a function $f$ in the model can be called on a function $g$ defined later, $g$ can be non computable at the stage where $f$ is defined.
\item the functions $(\Nat \to \Nat) \to \Nat$ are continuous, in the sense that for any $f : (\Nat \to \Nat) \to \Nat$ and $\alpha : \Nat \to \Nat$ with a code, there exists a modulus $n$ such that $\forall \beta, \restr\alpha n = \restr \beta n \implies f(\alpha) = f(\beta)$.
\item realizers can do an unbounded search,
as long as the meta-theory can prove that the search will terminate.
\end{enumerate}

The Kripke-like semantic realizability relation we gave, and the fact we state a property
about a possible future, strongly leads us to a generalization on some Kripke model.
The category semantic way of giving a Kripke model is to consider a category $\bC$,
a pre-ordered set $(W, \leq)$ and to give a functor $F : W \to \bC$.
We will follow this guideline by constructing a well-designed category for our work,
where morphisms preserve the information we expect.


\subsubsection{Evidenced frames with data types}
Observe that the functions which the former conditions refer to
are actually individuals witnessed by codes in our model.
Technically, this was handled by means of HOL-terms of the appropriated sorts
and the relativization predicate $\sortPred{\termt}$.
Again, we would like to maintain the distinction between terms witnessing individuals (the \emph{data types})
and realizers for formulas.
Therefore, we extend the definition of evidenced frames to account for data types:
those are evidenced frames for which we explicitly add a representation of $\bN$.
This can be seen as taking an evidenced frame $\EFE$
and pulling back from its category of assemblies a natural number object.
For this definition, as we want at least system T functions,
we also require an encoding (which is the one we expect for assemblies)
of functions, and thus a minimal system T types syntax.


\begin{definition}[Evidenced Frame with data types]
  An evidenced frame with data types (EFdata, for short),
  is a tuple $(\Phi,E,\relEFdot, \cod \cdot, e_0, e_S, e_{\rec})$ where:
  \begin{itemize}
  \item $(\Phi,E,\relEFdot)$ is an evidenced frame.
  \item $\cod \cdot : \bN \to \Phi$ is an encoding function. We extend it naturally for types on
    \[T,U \Coloneq \bN \mid T \to U\]
    by, for any $f : T \to U$:
    \[\cod f \defeq \prod_{x \in T} \PropImpl{\cod x}{\cod{f(x)}}\]
  \item $\relEF{e_0}{\top}{\cod 0}$
  \item for all $n \in \bN$, $\relEF{e_S}{\cod n}{\cod{n + 1}}$
  \item for all functions $f : \bN \to \Phi$,
    \[\relEF{e_{\rec}}{\top}{\PropImpl{f(0)}{\PropImpl{\left(\prod_{n \in \bN}\PropImpl{\cod n}{\PropImpl{f(n)}{f(n+1)}}\right)}{\prod_{n \in \bN} \PropImpl{\cod n}{f(n)}}}}\]
  %\item for all type $T$ as previously defined, let $\rec_T$ be the recursor $T \to (\bN \to T \to T) \to \bN \to T$, then $\relEF{e_{\rec}}{\top}{\cod{\rec_T}}$
  \end{itemize}
\end{definition}

\begin{remark}
  For any $n \in \bN$, $\cod n$ is realized by $S^n 0$. Also, any system T definable function is realized by the naturally associated term.
\end{remark}

To construct the category of EFdatas, we also need to define morphisms.
The notion of morphism we introduce is only intended to state a correct generalized version
of \Cref{thm:FT}, they are (very) strict morphisms which preverve every construction
(they preserve the evidences, the functions on propositions, \textit{etc.})
and are not to be considered as the natural notion of morphism for EFdata.
For example, EF morphisms as defined in \cite{CohMiqTat21} do not require
the constructions and morphism to commute on the nose.

\begin{definition}[Strict EFdata morphism]\label{def:efdata}
  Let $\EFE_1,\EFE_2$ be two EFdata (each component of which will be written respectively $E_1,\Phi_1,\ldots$ and $E_2,\Phi_2,\ldots$). A morphism of EFdata is the data of two functions $F_{\Phi} : \Phi_1 \to \Phi_2$ and $F_E : E_1 \to E_2$ (we will just write $F$) commuting with every constructor of an EFdata.

  We define $\CatEFData$ as the category whose objects are EFdatas, and morphisms are those defined above.
\end{definition}

With this notion of morphism, we can formalize the \emph{future world} notion by taking
a pre-order $\bC$ and constructing a functor $\bC \to \CatEFData$.
This makes it easy to define the condition that in any world and infinite binary tree $T$
at this world, there is a future in which a path in $T$ exists.


To generalize our argument in the setting of EF, we need some computational conditions. To begin with, we need to
%\emnote{add a sentence on how this is a faithful generalization of relativized quantifications.}
%\emnote{to do}
have a strong notion underlying the quantifier $\exists$, that we call explicit existential. The explicit existential allows one to use a proof of $\exists x, \varphi$ to extract an object $a$ such that $\varphi$ is true on $a$. In the presence of effects, and even more so with classical logic,
the witness used to prove $\exists x, \varphi$ can be impossible to retrieve, making
this explicit existential not realized \cite{Herbelin05}.
The explicit existential is thus a natural condition: when taking the relativized version of $\exists$, we expect the proof to be able to give an explicit witness by its code, and explicit existential ensures that this code of witness indeed retrieves the witness.
\begin{definition}[Explicit existential]
  An EFdata is said to have explicit existential if there is an evidence $e$ such that for any system T type $\tau$ and any function $\varphi(-) : \tau \to \Prop$ there exists $a \in \tau$ such that
  \[\relEF{e}{\exists x^\tau, \cod x \land \varphi(x)}{\cod a \land \varphi(a)}\]
\end{definition}


\subsubsection{Continuity}
Now, we formalize the continuity condition in the setting of EFdatas.
Continuity in computable systems is well-studied notion, for which a wide literature exists especially
in constructive settings \cite{these_baillon}.
For the purpose of this work, we will only consider the following (weak) version of continuity.

\begin{definition}[Continuity]
  Let $(\Phi,E,\relEFdot, \cod\cdot, e_0,e_S,e_{\rec})$ be an EFdata. This EFdata is said to have continuity if
  \begin{multline*}
    \forall f : (\bN \to \bN) \to \bN, \forall \alpha : \bN \to \bN, \forall \relEF{t}{\top}{\cod f},
    \\\forall \relEF{u}{\top}{\cod \alpha}, \exists n \in \bN,
    \forall \beta:\bN\to\bN,\restr \alpha n = \restr \beta n \implies f(\alpha) = f(\beta)
  \end{multline*}
\end{definition}
\begin{example}
Instead of oracles $\oracle_n$ interpreting functions $\bN \to \bN$, we could add as an oracle a program $\oracle$ such that $\oracle\;t$ reduces to $\rtt$ or $\rff$ depending on whether $t$ (weakly) terminates or not, supposing $t$ is closed and does not contain $\oracle$. In this case, it is possible to realize the function deciding if a path $\alpha : \bN \to \bB$ is the constant path $0$ by reading each bit of $\alpha$ until its first $1$. This function is not continuous, so the realizability model we could build on this computational system does not have continuity. For most reasonnable computational systems not adding non computable higher order function and without \texttt{quote} instruction, continuity is satisfied.
\end{example}


\subsubsection{Unbounded search}
% By analysing in details the proof of theorem \ref{thm:FT}, in addition to the two main conditions, two technical conditions are needed.

%\emnote{todo: introductory sentence}
Another principle that is used in the theorem \ref{thm:FT} but need not be realized in any EF is the ability to conduct an unbounded search. To find the uniform bound, we use a fixpoint akin to the $\mu$ operator from \cite{Kleene1943}. This is a reasonnable assumption: for instance, every PCA implements unbounded search thanks to the fixpoint combinator $Y$.
%This construction is not realized in some typed settings. For example, we can easily construct a realizability model of Heyting Arithmetic using system T functions: those functions are total and contain recursive primitive functions, hence they can't be stable under $\mu$.


%These condition arise from two constructions quite natural but not always true for an arbitrary realizability model:
%\begin{itemize}
%\item to find the uniform bound we use a fixpoint creating an unbounded search. This operation is akin to the $\mu$ operator from \cite{Kleene1943}, and is not realized in some typed settings. For example, we can easily construct a realizability model of Heyting Arithmetic using system T functions: those functions are total and contain recursive primitive functions, hence they can't be stable under $\mu$.

%\end{itemize}

\begin{definition}[Unbounded search]
  An EFdata is said to have unbounded search if there exists $e$ such that, for any $f : \bN \to \bN$ having at least one zero,
  \[\relEF{e}{\cod f}{(\exists (n : \bN), \cod n \land f(n) = 0)}\]
\end{definition}
\begin{example}
Typed realizability settings based on the $\lambda$-calculus or any other computational system where all realizers have to be
terminating would forbid such unbounded search,
but extension to PCF or untyped settings naturally allow for such an operator.
\end{example}


\subsubsection{The robust theorem}
We can now state our generalized theorem about $\FT$. The conditions are the one introduced above, but they are not needed to be satisfied in every world. In the proof of \Cref{thm:FT}, there are two worlds: the one from which we get the bar, and the one in which we get the path avoiding $C(b)$. The continuity and explicit existential only need to be satisfied in the latter and, up to going to an even further future, can be checked only on a dense set of worlds. The unbounded search is used on the base world (the one containing our model), which is the only use of this hypothesis.

\begin{theorem}\label{thm:main}
  Let $\EFE$ be an EFdata with unbounded search. Let $(W,\leq,\bOne)$ be an ordered set with lower bound $\bOne$ and $F : W \to \CatEFData$ be a functor such that $F(\bOne) = \EFE$. If the following conditions are satisfied:
  \begin{itemize}
  \item there is a dense subset $W' \subseteq W$ such that for any $w \in W', F(w)$ has continuity and explicit existential.
  \item for any $w \in W$, function $B : \List(\bB) \to \bB$ with an infinite path
  and a code in $w$, there is an element $w' \geq w$,
  a code $e_\alpha$ of an infinite path $\alpha$ in $B$
  and a code $e \in E_{w'}$ such that for any $n \in \bN$,
  $\relEF{e}{\cod n}{\restr \alpha n \in B}$
  \end{itemize}
  then $\EFE \real \FT$.
\end{theorem}

\begin{proof}
  We apply the proof of theorem \ref{thm:FT} in the general setting. To make the proof easier to read, we consider the types $\Bool$ and $\List(\Bool)$, as they can be encoded inside integers and the usual manipulations can be simulated on the encodings.

  The proposition we want to prove is that there exists $\witx \in E$ such that for any predicate $B : \List(\Bool) \to \Phi$ closed by extension,
  \begin{multline*}
    \witx\real (\forall \alpha^{\{\Nat \to \Bool\}}, \exists n^{\{\Nat\}}, \restr \alpha n \in B) \implies\\
    \exists n^{\{\Nat\}}, \forall \alpha^{\{\Nat \to \Bool\}}, \restr \alpha n \in B
  \end{multline*}
  
  We assume there is $b$ witnessing the bar on $B$, and the definition of $C(b)$ from it is system T defined: this ensures that we can define the same function using the witnesses $\witZ,\witS,\witRec$. In the definition of $n_{C(b)}$, we can't define the fixpoint by itself, but we can define the function $C'_b$ which, for any $n$, computes whether every $\ell \in \List(\Bool)$ of size $n$ is inside $C(b)$. This function has a code $e_{C'_b}$.

  By hypothesis, the evidenced frame has unbounded search, so we can apply it to $\lnot \circ C'_b$ (because we search for a $n$ such that $C'_b(n) = 1$). Combining it with the code $e_{C'_b}$, this gives an evidenced of a uniform bound. Thus, all that is left to prove is that $\lnot \circ C'_b$ indeed has a $0$.

  Suppose that $C'_b(n) = 0$ for any $n$. This means that for any $n \in \bN$, there is a list of size $n$ avoiding $C$. Using Weak KÃ¶nig's Lemma on $\complement C$ (which is a tree), we find a path $\alpha : \bN \to \bB$ such that $\restr \alpha n \notin C$ for any $n \in \bN$. By hypothesis on our functor $W \to \CatEFData$, we find $w' \in W$ and a code $e_\alpha \in \cod \alpha$ in $w'$. By the other hypothesis, we can assume (up to going to a future world) that $F(w')$ has continuity.

  Let $g$ be the morphism from $\EFE$ to $F(w')$. By construction of morphisms, we have
  \[g(b)\real g(\forall \alpha^{\{\Nat \to \Bool\}}, \exists n^{\{\Nat\}}, \restr \alpha n \in B)\]
  but as $g$ commutes with $\cod -$, with $\implies$, and with quantification $\forall$, we deduce that
  \[g(b)\real \forall \alpha^{\{\Nat \to \Bool\}}, \exists n^{\{\Nat\}}, \restr \alpha n \in B\]
  hence, $g(b) e_{\alpha} \real \exists n^{\{\Nat\}}, \restr \alpha n \in g(B)$. Using the fact that $g(b)$ is a code of a function $(\bN \to \bN) \to \bN$, we can apply continuity to find $m$ such that $\restr \alpha m = \restr \beta m \implies g(b) \alpha = g(b) \beta$ for any $\beta : \bN \to \bN$ with a code. This means that we can apply the same argument as in theorem \ref{thm:FT} to have a contradiction~: taking $M$ the maximum of this $m$ and of the encoded $n^{\{\Nat\}}$ by $g(b) e_{\alpha}$ (that we can take by explicit existential), we get $\restr \alpha M \in C(b)$, which is contradicting the fact that $\alpha$ always avoids $C(b)$.
\end{proof}
