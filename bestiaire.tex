\subsection{First exploration of the model}

Given our model, any closed term typable in system T can be written as a closed term and be realized by a term canonicaly associated to it. This means that, for example, the functions $+$ or $\times$ can be expressed both as objects of the sort $\Nat \to \Nat \to \Nat$ and as realizers computing these functions.

For example, every boolean operation $\land,\lor,\lnot$ can be written using $\rec_{\Bool}$. Similarly, functions on lists that can be defined by a fold function can be written inside our system both in HOL and as realizer. We thus assume given functions like the length $|\ell|$ of a list $\ell$.

In particular, for this reason, any sort on the grammar
\[S,T\Coloneq \Bool\mid\Nat\mid\List(S)\mid S\times T\]
has decidable equality: they even have decidable order $\leq$ where
\begin{itemize}
\item if $b,b' : \Bool$, $b \leq b'$ means that $b$ is false or $b'$ is true
\item if $n,m : \Nat$, $n \leq m$ is the natural inequality on integers
\item if $\ell,\ell' : \List(S)$, $\ell \ListInf \ell'$ is the prefix order
\item if $\langle x,y\rangle,\langle x',y'\rangle : S \times T$, $\langle x,y\rangle \leq \langle x',y'\rangle$ is defined as $(x \leq x') \land (y\leq y')$
\end{itemize}
Saying they are decidable order means that there are a term $\termt_{\leq}$ and a $\lambda$-term $t_{\leq} \realU (S\to S \to \Bool)(\termt_{\leq})$ such that $\termt(\varx,\bvary) \iff \varx \leq \bvary$.
We will call those the discrete sorts.

\subsubsection{Bounded formulas}

Using booleans operations, it is straightforward that propositionnal logic over the atomic formulas
$t = u \mid t \leq u$
are themselves decidables, as soon as $t$ and $u$ are typed in a sort $S$ as previously mentionned.

Bounded formulas are defined in a similar way as for $\Sigma_0^1$ formulas of arithmetic.  Using the recursors of $\Nat$, $\Bool$ and $\List$, as well as projections, any bounded formula implying only quantifications on discrete sorts and atomic formulas on discrete sorts (parameters can be functions).

\subsubsection{Binary lists}

However, for lists, the quantification $\forall \ell \ListInf \ell'$ with parameter $\ell'$ is not the one we will use. To be able to define $\forall \ell, |\ell| \leq n \implies \varphi$, we define a function $\ListEnum$ given by the binary decomposition of the number $n$. If $\IntBaseD n$ is the binary decomposition of $n$ in base $2$ as a list of booleans, then let $\ListEnum(n)$ be the list $\IntBaseD{n+1}$ in which we leave out the strongest bit $1$. The function $\ListEnum$ is a bijection from $\bN$ to $\List(\bB)$ which goes by increasing size, allowing the use of the quantification
\[\forall \ell^{\List(\Bool)}, |\ell| \leq n \implies \varphi(\ell)\]
by the encoding
\[\forall m^{\Nat}, m \leq 2^n \implies \varphi(\ListEnum(m))\]

\subsubsection{Finite and infinite path}

Given a function $\alpha : \Nat \to \Bool$ and a number $n$, we write $\restr \alpha n : \List(\Bool)$ for the list of the $n$ first values of $\alpha$. Conversely, given a list $\ell : \List(\Bool)$, we write $\ell0^\infty$ for the function $\Nat \to \Bool$ which associate $\ell_i$, the $i$-th value of $\ell$, to $i < |\ell|$, and $0$ to any $i \geq |\ell|$.

%\subsubsection{Boolean operations}
%
%The usual connectives can be defined as boolean operations:
%\begin{align*}
%  \BoolNot &\defeq \rec_{\Bool}\;\rff\;\rtt &: \Bool \to \Bool\\
%  \BoolOr &\defeq \lambda b.\rec_{\Bool}\;\rtt\;b &: \Bool \to \Bool \to \Bool\\
%  \BoolAnd &\defeq \lambda b.\rec_{\Bool}\;b\;\rff &: \Bool \to \Bool \to \Bool\\
%  \BoolImp &\defeq \lambda b.\rec_{\Bool}\;\rtt\;(\BoolNot\;b) &: \Bool \to \Bool \to \Bool\\
%  \BoolEq &\defeq \rec_{\Bool}\;(\lambda x.x)\;\BoolNot &: \Bool \to \Bool \to \Bool
%\end{align*}
%
%These function extend to operations on lists of booleans:
%\begin{align*}
%  \bigwedge &\defeq \rec_{\List}\;\rtt\; (\lambda b\;\_\;b'. b\BoolAnd b')&: \List(\Bool) \to \Bool\\
%  \bigvee &\defeq \rec_{\List}\;\rff\;(\lambda b\;\_\;b'. b\BoolOr b') &: \List(Bool) \to \Bool
%\end{align*}
%
%\subsubsection{Arithmetic}
%
%The usual arithmetic functions are
%\begin{align*}
%  +&\defeq \lambda n.\rec_{\Nat}\;(\lambda\;\_.n)\;(\lambda\;\_\;m.\lamS\;m) &: \Nat \to \Nat \to \Nat\\
%  \times&\defeq \lambda n.\rec_{\Nat}\;(\lambda\;\_.\lamZ)\;(\lambda\;\_\;m.m+n) &: \Nat \to \Nat \to \Nat\\
%  n^m &\defeq \rec_{\Nat}\;(\lambda\;\_.\lamS\;\lamZ)\;(\lambda\;\_\;m.m\times n)\;m&: \Nat\\
%  \predNat &\defeq \rec_{\Nat}\;\lamZ\;(\lambda\;n\;\_.n) &:\Nat \to \Nat\\
%  - &\defeq \lambda n.\rec_{\Nat}\;n\;(\lambda\;\_\;m.\predNat\;m) &:\Nat\to\Nat\to\Nat
%\end{align*}

%we can also write the following function:
%\begin{align*}
%  ``\eqNat"& \defeq\rec_{\Nat}\;(\rec_{\Nat}\;\rtt\;(\lambda\;\_\;\_.\rff))\;(\lambda\;\_\;f. (\rec_{\Nat}\;\rff\;(\lambda\;m\;\_.f\;m))) &:\Nat \to \Nat \to \Bool\\
%\end{align*}
%which realizes the graph of the equality. Hence, it can be proved by double induction that
%\[\forall n,m^{\{\Nat\}}, n = m \iff (n \eqNat m) = \rtt\]
%
%We also define an enumeration of integer:
%\begin{align*}
%  \NatToList &\defeq \rec_{\Nat}\;\nil\;(\lambda\;n\;\ell.n\append\ell) &: \Nat \to \List(\Nat)
%\end{align*}
%which reduces on $\overline n$ to $[\overline k \mid k < n]$.
%
%\subsubsection{Operations on lists}
%
%We first define the list concatenation:
%\begin{align*}
%  \concat &\defeq \lambda \ell.\rec_{\List}\;\ell\;(\lambda a\;\_\;\ell'.a\append\ell') &: \List(S) \to \List(S) \to \List(S)
%\end{align*}
%Supposing that $S$ is a sort with decidable equality (meaning that there is a function $e : S \to S \to \Bool$ such that $s = s'$ is equivalent to $e(s,s') = \rtt$), then we construct the prefix order (which is decidable) by
%\begin{multline*}
%  \ell \ListInf \ell' \defeq \rec_{\List}\;(\lambda\_.\rtt)\;(\lambda a\;\_\;\ell_0.\rec_{\List}\;\rff\;(\lambda b\;\ell'_0\;\_.a =_S b \BoolAnd \ell_0\;\ell'_0)) \\:\List(S)\to\List(S)\to \Bool
%\end{multline*}
%
%Given a function $f : S \to T$, we can make the map function:
%\[
%\mapL \defeq \lambda f.\rec_{\List}\;\nil\;(\lambda a\;\_\;\ell.(f\;a)\append \ell) : (S \to T) \to \List(S) \to \List(T)
%\]
%and, for a function $f : S \to \Bool$, we can make the filter function:
%\begin{multline*}
%\filterL \defeq \lambda f.\rec_{\List}\;\nil\;(\lambda a\;\_\;\ell.\rec_{\Bool}\;(a\append\ell)\;\ell\;(f\;a)) \\: (S \to \Bool) \to \List(S) \to \List(S)
%\end{multline*}
%
%Given a function $f : \Nat \to \Nat$, we define the list of its $n$ first values as
%\[\restr{f}{} \defeq \rec_{\Nat}\;\nil\;(\lambda\;n\;\ell.(f\;n) \append \ell)\]
%
%For an integer $n$, we define it writting in base $2$ as follows:
%\[
%  \NatToBool \defeq \rec_{\Nat}\;\rff\;(\lambda\;\_\;\_.\rtt) :\Nat\to\Bool\]
%\begin{multline*}
%  f \defeq \lambda \langle \ell, n \rangle.\rec_{\Nat}\;\langle \ell,n\rangle (\lambda\;\_\;\_.\langle (\NatToBool(n\% 2)) \append \ell, n/2\rangle)\\
%  : (\List(\Bool)\times\Nat) \to (\List(\Bool)\times\Nat)
%\end{multline*}
%\[
%\IntBaseD n \defeq \rec_{\Nat}\;\langle\nil,n \rangle\;(\lambda\;\_.f)\;n : \Nat \to \List(\Bool)
%\]

\subsubsection{Predicate given a bar}

We will now write the term realizing $\WFT$.
Fix a monotonous predicate $B : \List(\Bool) \to \Prop$, \textit{i.e.} such that
\[\forall \ell, \ell'^{\List(\Bool)}, \ell \ListInf \ell' \implies B(\ell) \implies B(\ell')\]
a bar for this predicate is a realizer (in somme reduction context $\enviro$)
\[b \realP{\enviro}{} \forall \alpha^{\{\Nat \to \Bool\}}, \exists n^{\{\Nat\}}, B(\restr \alpha n)\]
Suppose given such a bar $b$.

\emnote{insister sur comment b calcule et $\pi_1$ etc...}
Remark that if $\restr\alpha{\pi_1(b(\alpha))}\ListInf\ell$, then by the realizer of the monotonicity of $B$ and the fact that $B(\restr\alpha{\pi_1(b(\alpha))})$, we can deduce (in the realizability sense) that $B(\ell)$ holds.

Our goal is to construct a monotonous subset $C\subseteq B$ which is decidable. For this, it suffices to find a bounded formula such that any $\ell$ satisfying this formula is in $B$. From the previous remark, we only need to show that if $C(\ell)$, then there is a prefix of $\ell$ of the form $\restr{\alpha}{\pi_1(b(\alpha))}$.

We then use this with a bounded quantification: we enumerate every list $\ell$ and, each time, add to $C$ the list $\restr{\ell0^\infty}{\pi_1(b(\ell0^\infty))}$ and every extension, as long as those extensions are of lower size than $\ell$. This can also be rewritten as follows: given a list $\ell$, checking whether $\ell \in C$ amounts to checking whether there exists a list $\ell'$ of size lower than $|\ell|$ such that $\restr{\ell'0^\infty}{\pi_1(b(\ell'0^\infty))}\ListInf \ell$.

This automatically gives a term
\[C_b(\ell) \defeq \eval (\exists \ell'^{\List(\Bool)}, |\ell'| < |\ell| \land \restr{\ell'0^\infty}{\pi_1(b(\ell'0^\infty))} \ListInf \ell)\]
where $\eval\varphi$ is the boolean truth value of $\varphi$, given $\varphi$ is decidable (which is it by the previous arguments).

Now, we define the following predicate
\[C'_b(n) \defeq \eval (\forall \ell^{\List(\Bool)}, |\ell| = n \implies C(\ell))\]
$C'$ is decidable as $C$ is and the quantification is bounded. If $C'(n)$ is realized, then $n$ is a uniform bound for $C$, hence for $B$. Thus, the term we construct is an unbounded search to find a $n$ satisfying $C'_b(n)$. Let $Y \defeq \lambda f.(\lambda x.f\;(x\;x))(\lambda x.f\;(x\;x))$, we define
\[n_{C_b} \defeq Y(\lambda f.\lambda n.\rec_{\Bool}\;n\;(f\;(S\;n))\;C'_b(n))\;0\]
Ignoring the final $0$ in $n_{C_b}$, the defined function $f$ is such that\emnote{rewrite}
\[\begin{cases}
n_{C_b}\;n \redRT n \text{if } C'_b(n)\\
n_{C_b}\;n \redRT n_{C_b}\;(n+1) \text{otherwize}
\end{cases}\]
so either $n_{C_b}$ runs infinitely many steps, and for every $n$, $C'_b(n)$ is false (meaning that there exists $\ell_n \notin C$ of size $n$) or $n_{C_b} \real \Nat$ and it is a uniform bound.

%For this, the idea is to consider every list by the order given by our enumeration. For a given list $\ell$, the bar $b$ can be applied to the function $\ell 0^\infty$ to have a list $\ell'$ (either a prefix of $\ell$ or $\ell$ followed by a finite number of $0$).
%
%The algorithm is the following to decide whether a list $\ell_0$ is in $C$. We consider every list $\ell$ of size $n \leq |\ell_0|$: $\ell_0 \in C$ exactly when there is some list $\ell'$ such that its associated $\ell'$ has as an extension $\ell_0$.
%
%The idea is thus to add every extension of $\ell_0$ when the given extension is not already decided. By the fact that $B$ is monotonous and that the bar gives a predicate inside $B$, we know that $C$ is a subset of $B$. As $C$ is made by adding extensions, it is also monotonous, and because we only have to check a finite number of lists to decide whether a given list is in $C$, this is decidable.
%
%The associated term is the following:
%\begin{multline*}
%C(b) \defeq \lambda \ell. \bigvee \mapL\;((\lambda \ell'. \ell'\ListInf \ell)\circ b \circ \ListEnum)\;(\NatToList\;(2^{|\ell| + 1} - 1)) \\: \List(Bool) \to \Bool
%\end{multline*}
%
%Then, we can define an algorithm which tries every list of a given size $n$ and checks if every such list is in $C$. If this converges, then the given $n$ it defines is a uniforme bar on $C$ (hence on $B$):
%
%\begin{multline*}
%  n_{C(b)} \defeq \Theta(\lambda f\;n.\rec_{\Bool}\;n\;(f\;(\lamS\;n))\\
%  (\bigwedge\;\mapL\;(C\circ \ListEnum)\;(\restr{\NatToList\;(2^{n + 1} - 1)}{2^n})))\;\lamZ
%\end{multline*}
%
%where $\Theta$ is the Turing fixpoint, defined by
%\[ \theta \defeq \lambda x\;y.y\;(x\;x\;y)\qquad
%\Theta \defeq \theta\;\theta\]
